# Поразрядная сортировка целых чисел с чётно-нечётным слиянием Бэтчера (SEQ | MPI)

- Студент: Черемхин Андрей Александрович, группа 3823Б1ПР3
- Технология: SEQ | MPI
- Вариант: 1

## Введение

Цель задачи — реализовать сортировку целых чисел (int) поразрядным алгоритмом (radix sort) и параллельную MPI-версию,
в которой локально отсортированные блоки объединяются с помощью чётно-нечётного слияния Бэтчера (Batcher odd-even merge)
по процессам.

## Постановка задачи

На вход подаётся вектор целых чисел. Требуется вернуть этот вектор, отсортированный по неубыванию.

Тип входных данных:

```cpp
using InType = std::vector<int>;
```

Тип выходных данных:

```cpp
using OutType = std::vector<int>;
```

## Базовый алгоритм (Sequential)

Используется LSD radix sort по байтам (4 прохода для 32-битного int):

- на каждом проходе выполняется стабильная сортировка подсчётом по текущему байту
- для корректной обработки отрицательных чисел используется преобразование ключа: `key = (uint32_t)value ^ 0x80000000`
  (это переводит порядок signed в порядок unsigned)

Сложность:

- O(4 * n) по времени
- O(n) по памяти

## Схема распараллеливания (MPI): Бэтчер (odd-even merge) по процессам

1. Rank 0 делит входной массив на блоки и распределяет их по процессам (`MPI_Scatterv`).
2. Каждый процесс сортирует свой блок локально тем же radix sort.
3. Далее выполняется сеть компараторов Бэтчера по процессам (для количества процессов = степень двойки):
   - на каждом компараторе два процесса обмениваются своими отсортированными блоками (`MPI_Sendrecv`)
   - выполняют слияние двух отсортированных массивов (merge)
   - процесс с меньшим rank оставляет “меньшую половину” своего размера, процесс с большим rank — “большую половину”
4. Rank 0 собирает итог (`MPI_Gatherv`) и рассылает результат всем (`MPI_Bcast`), чтобы `GetOutput()` был валиден на каждом процессе.

Примечание: если число процессов не является степенью двойки, используется безопасный fallback на чётно-нечётные соседние обмены
(odd-even transposition), чтобы задача корректно работала в любом запуске.

## Детали реализации

Структура задачи:

```
tasks/cheremkhin_a_radix_sort_batcher/
├── common/include/common.hpp
├── seq/include/ops_seq.hpp
├── seq/src/ops_seq.cpp
├── mpi/include/ops_mpi.hpp
├── mpi/src/ops_mpi.cpp
├── tests/functional/main.cpp
├── tests/performance/main.cpp
├── settings.json
├── info.json
└── report.md
```

Классы:

- `CheremkhinARadixSortBatcherSEQ`
- `CheremkhinARadixSortBatcherMPI`

## Проверка корректности

Functional-тесты (`tests/functional/main.cpp`) проверяют:

- сортировку уже отсортированного массива
- сортировку в обратном порядке
- наличие отрицательных чисел и повторов
- тривиальные случаи (1 элемент)

Ожидаемый результат вычисляется как `std::sort` над копией входа.

## Производительность

Performance-тест (`tests/performance/main.cpp`) генерирует детерминированный вектор размера \(2^20\) и сравнивает результат с `std::sort`.

Запуск (пример):

```bash
export PPC_NUM_THREADS=4
export PPC_NUM_PROC=4
export OMPI_ALLOW_RUN_AS_ROOT=1
export OMPI_ALLOW_RUN_AS_ROOT_CONFIRM=1

python3 scripts/run_tests.py --running-type performance
```

## Источники

1. [Материалы курса: отчёт (требования и структура)](https://learning-process.github.io/parallel_programming_course/ru/common_information/report.html#overview-and-placement)

